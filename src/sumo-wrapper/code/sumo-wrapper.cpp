#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <cstdlib>
#include <ctime>
#include <sstream>
#include <map>
#include <ctype.h> // toupper
#include "cInstance.hpp"
#include "simpleXMLParser.hpp"

using namespace std;

string tlfile, networkfile, routesfile, summaryfile, vehroutefile, tripinfofile, emissionsfile;

typedef struct
{
	double 		GvR; 		// Original Green vs Red
	double 		nGvR; 		// Normalized GvR
	double 		duration;	// Total duration
	unsigned 	numVeh; 	// Vehicles arriving
	unsigned 	remVeh; 	// Vehicles not arriving
	double		stops;		// Number of stops
	double		fitness;	// Fitness
	// New stats
	double		meanTravelTime; // Mean Travel Time
	double		meanWaitingTime; // Mean Waiting Time
	long double	CO2;		// CO2 
	long double	CO;			// CO
	long double	HC; 		// HC
	long double	NOx;		// NOx
	long double	PMx;		// PMx
	long double	fuel;		// fuel
	long double	noise;		// noise
} tStatistics;

// Auxiliar functions


// Convert a number to string
string to_string(unsigned long v);

// Build XML additional file with new tlLogic tags from TL configuration
void buildXMLfile(const cInstance &c, const vector<int> &tl_times,
                  time_t t, const string &outputdir);

// Read TL configuration (generated by the algorithm)
void readTLtime(string tl_filename, vector<int> &tl);

// Build command for executing SUMO
static string buildCommand(const cInstance &c, time_t t, unsigned int seed,
                           const string &outpath);

// Write the result file 
void writeResults(const tStatistics &s, string filename);


// Calculating statistics
// Calculate GvR value
void calculateGvR(const cInstance &c, const vector<int> & tl_times, tStatistics &s);

// Analyze trip info obtaining how many vehicle arriving, number of stops, total duration, ...
void analyzeTripInfo(const cInstance &c, time_t t, tStatistics &s);
// Analyze Summary File
void analyzeSummary(const cInstance &c, time_t t, tStatistics &s);
// Calculate Fitness
double calculateFitness(const tStatistics &s, unsigned simTime);
// Analyze emission file
void analyzeEmissions(const cInstance &c, time_t t, tStatistics &s);

#include <sys/stat.h>
static bool is_directory (const string & path)
{
    struct stat sb;
    return (stat(path.c_str(), &sb) == 0 && S_ISDIR(sb.st_mode));
}

int main(int argc, char **argv)
{
	cInstance instance;
	tStatistics s;
	vector<int> tl_times;
	time_t current_time = time(0), t2, t3, t4;
	string cmd;

	if (argc < 4)
	{
		cout << "Usage: " << argv[0] << " <instance_file> <traffic light configuration> <result file> [<seed>] [<output directory>] [routes file]" << endl;
		exit(1);
	}

	instance.read(argv[1]);

        unsigned int seed;
        if (argc < 5) {
            cout << argv[0] << ": FIXME: generate a random seed!" << endl;
            exit (1);
        } else {
            seed = atoi(argv[4]);
        }

        string outputpath;
        if (argc < 6) {
            cout << argv[0] << ": FIXME: take current working dir as output directory!" << endl;
            exit (1);
            outputpath += instance.getPath();
        } else {
            outputpath = argv[5];
        }

        if (!is_directory(outputpath)) {
            cout << argv[0] << ": error: " << outputpath << " not found or not a directory" << endl;
            exit (1);
        }
        if (outputpath.back() != '/')
            outputpath.push_back('/');

	readTLtime(argv[2], tl_times);

        // Add instance name as a prefix
        outputpath += instance.getName();

	buildXMLfile(instance, tl_times, current_time, outputpath);

        routesfile = "";
        if (argc >= 7) {
            routesfile = argv[6];
        }

	cmd = buildCommand(instance, current_time, seed, outputpath);

	cout << "Executing sumo: " << cmd << endl;

	t2 = time(0);
	if (system(cmd.c_str())) {
            cout << "Executing sumo failed" << endl;
            exit (1);
        }
	t3 = time(0);

	cout << "Obtaining statistics ..." << endl;

	// Obtaining statistics (JM):
	calculateGvR(instance, tl_times, s);
	analyzeTripInfo(instance, current_time, s);
	analyzeSummary(instance, current_time, s);
//	analyzeEmissions(*instance, current_time, s); 
	s.fitness = calculateFitness(s, instance.getSimulationTime());

	writeResults(s, argv[3]);
	t4 = time(0);

	cout << "Total time: " << t4 - current_time << endl;
	cout << "SUMO time: " << t3 -t2 << endl;
	cout << endl;

	return 0;
}

// Convert a number to string
string to_string(unsigned long v)
{
	stringstream ss;
	ss << v;

	return ss.str();
}

void buildXMLfile(const cInstance &c, const vector<int> &tl_times,
                  time_t t, const string &path)
{
//	string xmlfile = c.getPath() + to_string(t) + "-" + c.getName() + ".add.xml";
        tlfile = path + ".add.xml"; 
	ofstream fout_xml(tlfile);
	unsigned nTL = c.getNumberOfTLlogics();
	vector<string> phases;
	unsigned nPhases;
	unsigned tl_times_counter = 0;

	fout_xml << "<add>" << endl;

	for (int i=0;i<nTL;i++)
	{
            phases = c.getPhases(i);
            nPhases = phases.size();
            fout_xml << "\t<tlLogic id=\"" << c.getTLID(i) << "\" type=\"static\" programID=\"1\" offset=\""
                     << tl_times[tl_times_counter++] << "\">" << endl;

		for (int j=0; j < nPhases;j++)
		{
                    fout_xml << "\t\t<phase duration=\"" << tl_times[tl_times_counter++] << "\" state=\"" << phases[j] << "\"/>" << endl;
		}
		fout_xml << "\t</tlLogic>" << endl;
	}
	fout_xml << "</add>" << endl;

	fout_xml.close();
}

void readTLtime(string tl_filename, vector<int> &tl)
{
	ifstream fin_tl(tl_filename.c_str());
	int t;
        if(fin_tl.fail()) {
            cerr << "error: cannot open file " << tl_filename << endl;
            exit(1);
        }
	fin_tl >> t;
	while(!fin_tl.eof())
	{
		tl.push_back(t);
		fin_tl >> t;
	}
	fin_tl.close();	
}

static string buildCommand(const cInstance &c, time_t t, unsigned int seed,
                           const string &outpath)
{
	string cmd = "sumo";
        networkfile = c.getPath() + c.getName () + ".net.xml";
        routesfile  = c.getPath()
            + (routesfile.empty()
               ? (c.getName () + ".rou.xml")
               : routesfile); // Routes file
        summaryfile = outpath + "-summary.xml";
        vehroutefile = outpath + "-vehicles.xml"; // Vehicle routes result
        tripinfofile = outpath + "-tripinfo.xml"; // tripinfo result
        emissionsfile = outpath + "-emissions.xml "; // Emissions result
	// Input files:
	cmd += " -n " + networkfile; 
	cmd += " -r " + routesfile;
        // This was created by buildXMLFile()
	cmd += " -a " + tlfile; // TL file 

	// Output files:
//	cmd += " --save-configuration " + name2 + ".cfg "; // Save configuration <= With this option configuration file is generated but no SUMO execution is performed
//	cmd += " --emission-output " + emissionsfile;
	cmd += " --summary-output "  + summaryfile; // Summary result
	cmd += " --vehroute-output " + vehroutefile;
	cmd += " --tripinfo-output " + tripinfofile;

	// Options:
	cmd += " -b 0 "; // Begin time
	cmd += " -e " + to_string(c.getSimulationTime()); // End time
	cmd += " -s -1 "; // route steps ???
	cmd += " --time-to-teleport -1 "; // Disable teleporting
	cmd += " --no-step-log "; // Disable console output
#ifndef SUMOVERSION
#define  SUMOVERSION 0x0220
#endif
        cmd += 
#if SUMOVERSION < 0x0220
                   "--device.hbefa.probability" 
#else
                   "--device.emissions.probability"
#endif
                   " 1.0 "; // Tripinfo file will include emissions stats	
        if (seed >= 0)
            cmd += "--seed " + to_string(seed); // random seed

	return cmd;
}

// GvR (Green vs Red)
// Requires tl configuration (no sumo simulation required)

// GvR = \sum_{i=0}^{totalPhases}{GvR_phase(i)}
// GvR_phase(i) = duration(i) * (number_of_greens(i) / number_of_reds(i))
// Larger values are better
// Disadvantages: - No normalized - yellow/red phases are not counted
// Alternatives: 
// Normaziled GvR: nGvR
// nGVR = 1/number_of_TL * \sum_{i = 0}^{number_of_TL}{ (\sum_{j=0}^{phases_TL(i)}{GvR_phase(j)})/ (\sum_{j=0}^{phases_TL(i)}{duration(j)}) }
// Larger values are better
// Advantages: - Normalized (0/1) - All phases are taken into account
void calculateGvR(const cInstance &c, const vector<int> & tl_times, tStatistics &s)
{
	unsigned nTL = c.getNumberOfTLlogics(); // Number of TL logics
	unsigned nPhases; // Number of phases of a TL
	unsigned nt; // Number of tl in a TL logic

	// auxiliar variables
	vector<string> phases;
	unsigned tl_times_counter = 0;
	double gvr, dur;
	
	s.GvR = s.nGvR = 0.0;
	for (int i=0; i < nTL; i++)
	{
		phases = c.getPhases(i);
		nPhases = phases.size();
		
		gvr = 0;
		dur = 0;

                tl_times_counter++; // skip offset

		for (int j=0; j < nPhases; j++)
		{
                    int red = 0, green = 0;
			nt = phases[j].size();
			for(int k = 0; k < nt; k++)
			{
                            unsigned char c = toupper((unsigned char) phases[j][k]);
                            if (c == 'R') red++;
                            else if (c == 'G') green++;
			}

			if (red == 0) red++;
			gvr += (green / (double) red) * (double) tl_times[tl_times_counter];
			dur += tl_times[tl_times_counter];
//                        cout << "i: " << i << ", j: " << j << ", tl: " << tl_times[tl_times_counter] << ", gvr: " << gvr << ", dur: " << dur << endl;
			tl_times_counter++;

		}
		s.GvR += gvr;
		s.nGvR += (gvr / dur);
//                cout << "s.GvR: " << s.GvR << ", nGvR: " << s.nGvR << endl;
	}
	s.nGvR /= (double) nTL;
}

void analyzeTripInfo(const cInstance &c, time_t t, tStatistics &s)
{
	string line;
	ifstream fin(tripinfofile.c_str());
	map<string, string> m;
	int position;

//	s.numVeh = 0;
	s.duration = 0;
	s.stops = 0;
	s.CO2 = 0;
	s.CO = 0;
	s.HC = 0;
	s.NOx = 0;
	s.PMx = 0;
	s.fuel = 0;
	s.noise = 0;

	getline(fin, line);
	while(!fin.eof())
	{
		if(isSubString(line,"id=",position))
		{
			// get map
			getPairMap(line, m);
	
//			s.numVeh++;
			s.duration += atof(m["duration"].c_str()); 
			s.stops += atof(m["waitSteps"].c_str()); 
		}
		else if(isSubString(line,"CO_abs=",position))
		{
			getPairMap(line, m);
	
			s.CO2 += atof(m["CO2_abs"].c_str());
			s.CO += atof(m["CO_abs"].c_str());
			s.HC += atof(m["HC_abs"].c_str());
			s.NOx += atof(m["NOx_abs"].c_str());
			s.PMx += atof(m["PMx_abs"].c_str());
			s.fuel += atof(m["fuel_abs"].c_str());
//			s.noise += atof(m["noise"].c_str());
		}

		getline(fin, line);
	}
// This is computed from the summary data.
//	s.remVeh = c.getNumberOfVehicles() - s.numVeh;
	fin.close();
}

void analyzeSummary(const cInstance &c, time_t t, tStatistics &s)
{
	string line, last_line;
	ifstream fin(summaryfile.c_str());
	map<string, string> m;
	int position;

	getline(fin, line);
	while(!fin.eof())
	{
		if(isSubString(line,"time=",position))
		{
			last_line = line;
		}
		getline(fin, line);
	}

	// get map
	getPairMap(last_line, m);

	s.meanTravelTime = atof(m["meanTravelTime"].c_str()); 
	s.meanWaitingTime = atof(m["meanWaitingTime"].c_str()); 
        s.numVeh = atoi(m["ended"].c_str());
        s.remVeh = atoi(m["running"].c_str()) + atoi(m["waiting"].c_str());
                    
	fin.close();
}

double calculateFitness(const tStatistics &s, unsigned simTime)
{
	return (s.duration + (s.remVeh * simTime) + s.stops) / (s.numVeh * s.numVeh + s.GvR);
}

void analyzeEmissions(const cInstance &c, time_t t, tStatistics &s)
{
	string line;
	ifstream fin(emissionsfile.c_str());
	map<string, string> m;
	int position;

	s.CO2 = 0;
	s.CO = 0;
	s.HC = 0;
	s.NOx = 0;
	s.PMx = 0;
	s.fuel = 0;
	s.noise = 0;

	getline(fin, line);
	while(!fin.eof())
	{
		if(isSubString(line,"id=",position))
		{
			// get map
			getPairMap(line, m);
	
			s.CO2 += atof(m["CO2"].c_str());
			s.CO += atof(m["CO"].c_str());
			s.HC += atof(m["HC"].c_str());
			s.NOx += atof(m["NOx"].c_str());
			s.PMx += atof(m["PMx"].c_str());
			s.fuel += atof(m["fuel"].c_str());
			s.noise += atof(m["noise"].c_str());
		}
		getline(fin, line);
	}

	fin.close();
}

void writeResults(const tStatistics &s, string filename)
{
	ofstream fout(filename.c_str());

	fout << s.GvR << " // Original Green vs Red" << endl;
	fout << s.nGvR << " // Normalized GvR" << endl;
	fout << s.duration << " // Total duration" << endl;
	fout << s.numVeh << " // Vehicles arriving" << endl;
	fout << s.remVeh << " // Vehicles not arriving" << endl;
        fout << (s.remVeh + s.numVeh) << " // Total vehicles" << endl;
	fout << s.stops << " // Number of stops" << endl;
	fout << s.fitness << " // Fitness" << endl;
	fout << s.meanTravelTime << " // Mean Travel Time" << endl;	
	fout << s.meanWaitingTime << " // Mean Waiting Time" << endl;
	fout << s.CO2 << " // CO2 " << endl;	
	fout << s.CO << " // CO" << endl;	
	fout << s.HC << " // HC" << endl;	
	fout << s.NOx << " // NOx" << endl;	
	fout << s.PMx << " // PMx" << endl;	
	fout << s.fuel << " // fuel" << endl;	
	fout << s.noise << " // noise" << endl;	
	fout.close();
}

